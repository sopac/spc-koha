.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "C4::Search 3pm"
.TH C4::Search 3pm "2012-07-03" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Search \- Functions for searching the Koha catalog.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See opac/opac\-search.pl or catalogue/search.pl for example of usage
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides searching functions for Koha's bibliographic databases
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "FindDuplicate"
.IX Subsection "FindDuplicate"
($biblionumber,$biblionumber,$title) = FindDuplicate($record);
.PP
This function attempts to find duplicate records using a hard-coded, fairly simplistic algorithm
.SS "SimpleSearch"
.IX Subsection "SimpleSearch"
( \f(CW$error\fR, \f(CW$results\fR, \f(CW$total_hits\fR ) = SimpleSearch( \f(CW$query\fR, \f(CW$offset\fR, \f(CW$max_results\fR, [@servers] );
.PP
This function provides a simple search \s-1API\s0 on the bibliographic catalog
.ie n .IP """input arg:""" 2
.el .IP "\f(CWinput arg:\fR" 2
.IX Item "input arg:"
.Vb 4
\&    * $query can be a simple keyword or a complete CCL query
\&    * @servers is optional. Defaults to biblioserver as found in koha\-conf.xml
\&    * $offset \- If present, represents the number of records at the beggining to omit. Defaults to 0
\&    * $max_results \- if present, determines the maximum number of records to fetch. undef is All. defaults to undef.
.Ve
.ie n .IP """Return:""" 2
.el .IP "\f(CWReturn:\fR" 2
.IX Item "Return:"
.Vb 4
\&    Returns an array consisting of three elements
\&    * $error is undefined unless an error is detected
\&    * $results is a reference to an array of records.
\&    * $total_hits is the number of hits that would have been returned with no limit
\&
\&    If an error is returned the two other return elements are undefined. If error itself is undefined
\&    the other two elements are always defined
.Ve
.ie n .IP """usage in the script:""" 2
.el .IP "\f(CWusage in the script:\fR" 2
.IX Item "usage in the script:"
.PP
my ( \f(CW$error\fR, \f(CW$marcresults\fR, \f(CW$total_hits\fR ) = SimpleSearch($query);
.PP
if (defined \f(CW$error\fR) {
    \f(CW$template\fR\->param(query_error => \f(CW$error\fR);
    warn \*(L"error: \*(R".$error;
    output_html_with_http_headers \f(CW$input\fR, \f(CW$cookie\fR, \f(CW$template\fR\->output;
    exit;
}
.PP
my \f(CW$hits\fR = @{$marcresults};
my \f(CW@results\fR;
.PP
for my \f(CW$r\fR ( @{$marcresults} ) {
    my \f(CW$marcrecord\fR = MARC::File::USMARC::decode($r);
    my \f(CW$biblio\fR = TransformMarcToKoha(C4::Context\->dbh,$marcrecord,q{});
.PP
.Vb 9
\&    #build the iarray of hashs for the template.
\&    push @results, {
\&        title           => $biblio\->{\*(Aqtitle\*(Aq},
\&        subtitle        => $biblio\->{\*(Aqsubtitle\*(Aq},
\&        biblionumber    => $biblio\->{\*(Aqbiblionumber\*(Aq},
\&        author          => $biblio\->{\*(Aqauthor\*(Aq},
\&        publishercode   => $biblio\->{\*(Aqpublishercode\*(Aq},
\&        publicationyear => $biblio\->{\*(Aqpublicationyear\*(Aq},
\&        };
.Ve
.PP
}
.PP
\&\f(CW$template\fR\->param(result=>\e@results);
.SS "getRecords"
.IX Subsection "getRecords"
( undef, \f(CW$results_hashref\fR, \e@facets_loop ) = getRecords (
.PP
.Vb 4
\&        $koha_query,       $simple_query, $sort_by_ref,    $servers_ref,
\&        $results_per_page, $offset,       $expanded_facet, $branches,$itemtypes,
\&        $query_type,       $scan
\&    );
.Ve
.PP
The all singing, all dancing, multi-server, asynchronous, scanning,
searching, record nabbing, facet-building
.PP
See verbse embedded documentation.
.SS "getIndexes"
.IX Subsection "getIndexes"
Return an array with available indexes.
.SS "buildQuery"
.IX Subsection "buildQuery"
( \f(CW$error\fR, \f(CW$query\fR,
\&\f(CW$simple_query\fR, \f(CW$query_cgi\fR,
\&\f(CW$query_desc\fR, \f(CW$limit\fR,
\&\f(CW$limit_cgi\fR, \f(CW$limit_desc\fR,
\&\f(CW$stopwords_removed\fR, \f(CW$query_type\fR ) = buildQuery ( \f(CW$operators\fR, \f(CW$operands\fR, \f(CW$indexes\fR, \f(CW$limits\fR, \f(CW$sort_by\fR, \f(CW$scan\fR, \f(CW$lang\fR);
.PP
Build queries and limits in \s-1CCL\s0, \s-1CGI\s0, Human,
handle truncation, stemming, field weighting, stopwords, fuzziness, etc.
.PP
See verbose embedded documentation.
.SS "searchResults"
.IX Subsection "searchResults"
.Vb 3
\&  my @search_results = searchResults($search_context, $searchdesc, $hits, 
\&                                     $results_per_page, $offset, $scan, 
\&                                     @marcresults, $hidelostitems);
.Ve
.PP
Format results in a form suitable for passing to the template
.SS "SearchAcquisitions Search for acquisitions"
.IX Subsection "SearchAcquisitions Search for acquisitions"
.SS "NZgetRecords"
.IX Subsection "NZgetRecords"
.Vb 1
\&  NZgetRecords has the same API as zera getRecords, even if some parameters are not managed
.Ve
.SS "NZanalyse"
.IX Subsection "NZanalyse"
.Vb 4
\&  NZanalyse : get a CQL string as parameter, and returns a list of biblionumber;title,biblionumber;title,...
\&  the list is built from an inverted index in the nozebra SQL table
\&  note that title is here only for convenience : the sorting will be very fast when requested on title
\&  if the sorting is requested on something else, we will have to reread all results, and that may be longer.
.Ve
.SS "NZorder"
.IX Subsection "NZorder"
.Vb 1
\&  $finalresult = NZorder($biblionumbers, $ordering,$results_per_page,$offset);
\&
\&  TODO :: Description
.Ve
.SS "enabled_staff_search_views"
.IX Subsection "enabled_staff_search_views"
\&\f(CW%hash\fR = \fIenabled_staff_search_views()\fR
.PP
This function returns a hash that contains three flags obtained from the system
preferences, used to determine whether a particular staff search results view
is enabled.
.ie n .IP """Output arg:""" 2
.el .IP "\f(CWOutput arg:\fR" 2
.IX Item "Output arg:"
.Vb 3
\&    * $hash{can_view_MARC} is true only if the MARC view is enabled
\&    * $hash{can_view_ISBD} is true only if the ISBD view is enabled
\&    * $hash{can_view_labeledMARC} is true only if the Labeled MARC view is enabled
.Ve
.ie n .IP """usage in the script:""" 2
.el .IP "\f(CWusage in the script:\fR" 2
.IX Item "usage in the script:"
.PP
\&\f(CW$template\fR\->param ( C4::Search::enabled_staff_search_views );
.SS "z3950_search_args"
.IX Subsection "z3950_search_args"
\&\f(CW$arrayref\fR = z3950_search_args($matchpoints)
.PP
This function returns an array reference that contains the search parameters to be
passed to the Z39.50 search script (z3950_search.pl). The array elements
are hash refs whose keys are name, value and encvalue, and whose values are the
name of a search parameter, the value of that search parameter and the \s-1URL\s0 encoded
value of that parameter.
.PP
The search parameter names are lccn, isbn, issn, title, author, dewey and subject.
.PP
The search parameter values are obtained from the bibliographic record whose
data is in a hash reference in \f(CW$matchpoints\fR, as returned by \fIBiblio::GetBiblioData()\fR.
.PP
If \f(CW$matchpoints\fR is a scalar, it is assumed to be an unnamed query descriptor, e.g.
a general purpose search argument. In this case, the returned array contains only
entry: the key is 'title' and the value and encvalue are derived from \f(CW$matchpoints\fR.
.PP
If a search parameter value is undefined or empty, it is not included in the returned
array.
.PP
The returned array reference may be passed directly to the template parameters.
.ie n .IP """Output arg:""" 2
.el .IP "\f(CWOutput arg:\fR" 2
.IX Item "Output arg:"
.Vb 1
\&    * $array containing hash refs as described above
.Ve
.ie n .IP """usage in the script:""" 2
.el .IP "\f(CWusage in the script:\fR" 2
.IX Item "usage in the script:"
.PP
\&\f(CW$data\fR = Biblio::GetBiblioData($bibno);
\&\f(CW$template\fR\->param ( \s-1MYLOOP\s0 => C4::Search::z3950_search_args($data) )
.PP
*OR*
.PP
\&\f(CW$template\fR\->param ( \s-1MYLOOP\s0 => C4::Search::z3950_search_args($searchscalar) )
.SS "GetDistinctValues($field);"
.IX Subsection "GetDistinctValues($field);"
\&\f(CW$field\fR is a reference to the fields array
.SH "AUTHOR"
.IX Header "AUTHOR"
Koha Development Team <http://koha\-community.org/>
