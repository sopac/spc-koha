.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "C4::Branch 3pm"
.TH C4::Branch 3pm "2012-07-03" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Branch \- Koha branch module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use C4::Branch;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The functions in this module deal with branches.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "GetBranches"
.IX Subsection "GetBranches"
.Vb 1
\&  $branches = &GetBranches();
.Ve
.PP
Returns informations about \s-1ALL\s0 branches, IndependantBranches Insensitive.
\&\fIGetBranchInfo()\fR returns the same information without the problems of this function 
(namespace collision, mainly).
.PP
Create a branch selector with the following code.
.PP
\fIin \s-1PERL\s0 \s-1SCRIPT\s0\fR
.IX Subsection "in PERL SCRIPT"
.PP
.Vb 10
\&    my $branches = GetBranches;
\&    my @branchloop;
\&    foreach my $thisbranch (sort keys %$branches) {
\&        my $selected = 1 if $thisbranch eq $branch;
\&        my %row =(value => $thisbranch,
\&                    selected => $selected,
\&                    branchname => $branches\->{$thisbranch}\->{branchname},
\&                );
\&        push @branchloop, \e%row;
\&    }
.Ve
.PP
\fIin \s-1TEMPLATE\s0\fR
.IX Subsection "in TEMPLATE"
.PP
.Vb 6
\&    <select name="branch">
\&        <option value="">Default</option>
\&        <!\-\- TMPL_LOOP name="branchloop" \-\->
\&        <option value="<!\-\- TMPL_VAR name="value" \-\->" <!\-\- TMPL_IF name="selected" \-\->selected<!\-\- /TMPL_IF \-\->><!\-\- TMPL_VAR name="branchname" \-\-></option>
\&        <!\-\- /TMPL_LOOP \-\->
\&    </select>
.Ve
.PP
Note that you often will want to just use GetBranchesLoop, for exactly the example above.
.IX Subsection "Note that you often will want to just use GetBranchesLoop, for exactly the example above."
.SS "GetBranchName"
.IX Subsection "GetBranchName"
.SS "ModBranch"
.IX Subsection "ModBranch"
\&\f(CW$error\fR = &ModBranch($newvalue);
.PP
This function modify an existing branch
.PP
\&\f(CW$newvalue\fR is a ref to an array wich is containt all the column from branches table.
.SS "GetBranchCategory"
.IX Subsection "GetBranchCategory"
\&\f(CW$results\fR = GetBranchCategory($categorycode);
.PP
\&\f(CW$results\fR is an ref to an array.
.SS "GetBranchCategories"
.IX Subsection "GetBranchCategories"
.Vb 1
\&  my $categories = GetBranchCategories($branchcode,$categorytype);
.Ve
.PP
Returns a list ref of anon hashrefs with keys eq columns of branchcategories table,
i.e. categorycode, categorydescription, categorytype, categoryname.
if \f(CW$branchcode\fR and/or \f(CW$categorytype\fR are passed, limit set to categories that
\&\f(CW$branchcode\fR is a member of , and to \f(CW$categorytype\fR.
.SS "GetCategoryTypes"
.IX Subsection "GetCategoryTypes"
\&\f(CW$categorytypes\fR = GetCategoryTypes;
returns a list of category types.
Currently these types are \s-1HARDCODED\s0.
type: 'searchdomain' defines a group of agencies that the calling library may search in.
Other usage of agency categories falls under type: 'properties'.
	to allow for other uses of categories.
The searchdomain bit may be better implemented as a separate module, but
the categories were already here, and minimally used.
.SS "GetBranch"
.IX Subsection "GetBranch"
\&\f(CW$branch\fR = GetBranch( \f(CW$query\fR, \f(CW$branches\fR );
.SS "GetBranchDetail"
.IX Subsection "GetBranchDetail"
.Vb 1
\&    $branch = &GetBranchDetail($branchcode);
.Ve
.PP
Given the branch code, the function returns a
hashref for the corresponding row in the branches table.
.SS "GetBranchesInCategory"
.IX Subsection "GetBranchesInCategory"
.Vb 1
\&  my $branches = GetBranchesInCategory($categorycode);
.Ve
.PP
Returns a href:  keys %$branches eq (branchcode,branchname) .
.SS "GetBranchInfo"
.IX Subsection "GetBranchInfo"
\&\f(CW$results\fR = GetBranchInfo($branchcode);
.PP
returns \f(CW$results\fR, a reference to an array of hashes containing branches.
if \f(CW$branchcode\fR, just this branch, with associated categories.
if ! \f(CW$branchcode\fR && \f(CW$categorytype\fR, all branches in the category.
.SS "DelBranch"
.IX Subsection "DelBranch"
&DelBranch($branchcode);
.SS "ModBranchCategoryInfo"
.IX Subsection "ModBranchCategoryInfo"
&ModBranchCategoryInfo($data);
sets the data from the editbranch form, and writes to the database...
.SS "CheckCategoryUnique"
.IX Subsection "CheckCategoryUnique"
if (CheckCategoryUnique($categorycode)){
  # do something
}
.SS "DeleteBranchCategory"
.IX Subsection "DeleteBranchCategory"
DeleteBranchCategory($categorycode);
.SS "CheckBranchCategorycode"
.IX Subsection "CheckBranchCategorycode"
\&\f(CW$number_rows_affected\fR = CheckBranchCategorycode($categorycode);
.SH "AUTHOR"
.IX Header "AUTHOR"
Koha Development Team <http://koha\-community.org/>
