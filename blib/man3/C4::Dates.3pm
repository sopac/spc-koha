.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "C4::Dates 3pm"
.TH C4::Dates 3pm "2012-07-03" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "C4::Dates.pm \- a more object-oriented replacement for Date.pm."
.IX Header "C4::Dates.pm - a more object-oriented replacement for Date.pm."
The core problem to address is the multiplicity of formats used by different Koha 
installations around the world.  We needed to move away from any hard-coded values at
the script level, for example in initial form values or checks for min/max date. The
reason is clear when you consider string '07/01/2004'.  Depending on the format, it 
represents July 1st (us), or January 7th (metric), or an invalid value (iso).
.PP
The formats supported by Koha are:
    iso \- \s-1ISO\s0 8601 (extended)
    us \- U.S. standard
    metric \- European standard (slight misnomer, not really decimalized metric)
    sql \- log format, not really for human consumption
    rfc822 \- Standard for using with \s-1RSS\s0 feeds, etc.
.SS "\->new([string_date,][date_format])"
.IX Subsection "->new([string_date,][date_format])"
Arguments to \fInew()\fR are optional.  If string_date is not supplied, the present system date is
used.  If date_format is not supplied, the system preference from C4::Context is used.
.PP
Examples:
.PP
.Vb 3
\&        my $now   = C4::Dates\->new();
\&        my $date1 = C4::Dates\->new("09\-21\-1989","us");
\&        my $date2 = C4::Dates\->new("19890921    143907","sql");
.Ve
.SS "\->output([date_format])"
.IX Subsection "->output([date_format])"
The date value is stored independent of any specific format.  Therefore any format can be 
invoked when displaying it.
.PP
.Vb 4
\&        my $date = C4::Dates\->new();    # say today is July 12th, 2010
\&        print $date\->output("iso");     # prints "2010\-07\-12"
\&        print "\en";
\&        print $date\->output("metric");  # prints "12\-07\-2010"
.Ve
.PP
However, it is still necessary to know the format of any incoming date value (e.g., 
setting the value of an object with \fInew()\fR).  Like \fInew()\fR, \fIoutput()\fR assumes the system preference
date format unless otherwise instructed.
.SS "\->format([date_format])"
.IX Subsection "->format([date_format])"
With no argument, format returns the object's current date_format.  Otherwise it attempts to 
set the object format to the supplied value.
.PP
Some previously desireable functions are now unnecessary.  For example, you might want a 
method/function to tell you whether or not a Dates.pm object is of the 'iso' type.  But you 
can see by this example that such a test is trivial to accomplish, and not necessary to 
include in the module:
.PP
.Vb 4
\&        sub is_iso {
\&            my $self = shift;
\&            return ($self\->format() eq "iso");
\&        }
.Ve
.PP
Note: A similar function would need to be included for each format.
.PP
Instead a dependent script can retrieve the format of the object directly and decide what to
do with it from there:
.PP
.Vb 3
\&        my $date = C4::Dates\->new();
\&        my $format = $date\->format();
\&        ($format eq "iso") or do_something($date);
.Ve
.PP
Or if you just want to print a given value and format, no problem:
.PP
.Vb 2
\&        my $date = C4::Dates\->new("1989\-09\-21", "iso");
\&        print $date\->output;
.Ve
.PP
Alternatively:
.PP
.Vb 1
\&        print C4::Dates\->new("1989\-09\-21", "iso")\->output;
.Ve
.PP
Or even:
.PP
.Vb 1
\&        print C4::Dates\->new("21\-09\-1989", "metric")\->output("iso");
.Ve
.ie n .SS """syspref"" \*(-- System Preference(s)"
.el .SS "``syspref'' \*(-- System Preference(s)"
.IX Subsection "syspref  System Preference(s)"
Perhaps you want to force data obtained in a known format to display according to the user's system
preference, without necessarily knowing what that preference is.  For this purpose, you can use the
psuedo-format argument \*(L"syspref\*(R".
.PP
For example, to print an \s-1ISO\s0 date (from the database) in the <systempreference> format:
.PP
.Vb 3
\&        my $date = C4::Dates\->new($date_from_database,"iso");
\&        my $datestring_for_display = $date\->output("syspref");
\&        print $datestring_for_display;
.Ve
.PP
Or even:
.PP
.Vb 1
\&        print C4::Dates\->new($date_from_database,"iso")\->output("syspref");
.Ve
.PP
If you just want to know what the <systempreferece> is, a default Dates object can tell you:
.PP
.Vb 1
\&        C4::Dates\->new()\->format();
.Ve
.SS "\->DHMTLcalendar([date_format])"
.IX Subsection "->DHMTLcalendar([date_format])"
Returns the format string for \s-1DHTML\s0 Calendar Display based on date_format.  
If date_format is not supplied, the return is based on system preference.
.PP
.Vb 1
\&        C4::Dates\->DHTMLcalendar(); #  e.g., returns "%m/%d/%Y" for \*(Aqus\*(Aq system preference
.Ve
.PP
\fIError Handling\fR
.IX Subsection "Error Handling"
.PP
Some error handling is provided in this module, but not all.  Requesting an unknown format is a 
fatal error (because it is programmer error, not user error, typically).
.PP
Scripts must still perform validation of user input.  Attempting to set an invalid value will 
return 0 or undefined, so a script might check as follows:
.PP
.Vb 1
\&        my $date = C4::Dates\->new($input) or deal_with_it("$input didn\*(Aqt work");
.Ve
.PP
To validate before creating a new object, use the regexp method of the class:
.PP
.Vb 2
\&        $input =~ C4::Dates\->regexp("iso") or deal_with_it("input ($input) invalid as iso format");
\&        my $date = C4::Dates\->new($input,"iso");
.Ve
.PP
More verbose debugging messages are sent in the presence of non-zero \f(CW$ENV\fR{\*(L"\s-1DEBUG\s0\*(R"}.
.PP
Notes: if the date in the db is null or empty, interpret null expiration to mean \*(L"never expires\*(R".
.PP
\fI\fI_prefformat()\fI\fR
.IX Subsection "_prefformat()"
.PP
This internal function is used to read the preferred date format
from the system preference table.  It reads the preference once, 
then caches it.
.PP
This replaces using the package variable \f(CW$prefformat\fR directly, and
specifically, doing a call to C4::Context\->\fIpreference()\fR during
module initialization.  That way, C4::Dates no longer has a
compile-time dependency on having a valid \f(CW$dbh\fR.
.PP
\fI\s-1TO\s0 \s-1DO\s0\fR
.IX Subsection "TO DO"
.PP
If the date format is not in <systempreference>, we should send an error back to the user. 
This kind of check should be centralized somewhere.  Probably not here, though.
