.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "C4::Serials 3pm"
.TH C4::Serials 3pm "2012-07-03" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Serials \- Serials Module Functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use C4::Serials;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Functions for handling subscriptions, claims routing etc.
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.SS "GetSuppliersWithLateIssues"
.IX Subsection "GetSuppliersWithLateIssues"
\&\f(CW$supplierlist\fR = \fIGetSuppliersWithLateIssues()\fR
.PP
this function get all suppliers with late issues.
.PP
return :
an array_ref of suppliers each entry is a hash_ref containing id and name
the array is in name order
.SS "GetLateIssues"
.IX Subsection "GetLateIssues"
\&\f(CW@issuelist\fR = GetLateIssues($supplierid)
.PP
this function selects late issues from the database
.PP
return :
the issuelist as an array. Each element of this array contains a hashi_ref containing
name,title,planneddate,serialseq,serial.subscriptionid from tables : subscription, serial & biblio
.SS "GetSubscriptionHistoryFromSubscriptionId"
.IX Subsection "GetSubscriptionHistoryFromSubscriptionId"
\&\f(CW$sth\fR = \fIGetSubscriptionHistoryFromSubscriptionId()\fR
this function prepares the \s-1SQL\s0 request and returns the statement handle
After this function, don't forget to execute it by using \f(CW$sth\fR\->execute($subscriptionid)
.SS "GetSerialStatusFromSerialId"
.IX Subsection "GetSerialStatusFromSerialId"
\&\f(CW$sth\fR = \fIGetSerialStatusFromSerialId()\fR;
this function returns a statement handle
After this function, don't forget to execute it by using \f(CW$sth\fR\->execute($serialid)
return :
\&\f(CW$sth\fR = \f(CW$dbh\fR\->prepare($query).
.SS "GetSerialInformation"
.IX Subsection "GetSerialInformation"
\&\f(CW$data\fR = GetSerialInformation($serialid);
returns a hash_ref containing :
  items : items marcrecord (can be an array)
  serial table field
  subscription table field
  + information about subscription expiration
.SS "AddItem2Serial"
.IX Subsection "AddItem2Serial"
\&\f(CW$rows\fR = AddItem2Serial($serialid,$itemnumber);
Adds an itemnumber to Serial record
returns the number of rows affected
.SS "UpdateClaimdateIssues"
.IX Subsection "UpdateClaimdateIssues"
UpdateClaimdateIssues($serialids,[$date]);
.PP
Update Claimdate for issues in @$serialids list with date \f(CW$date\fR
(Take Today if none)
.SS "GetSubscription"
.IX Subsection "GetSubscription"
\&\f(CW$subs\fR = GetSubscription($subscriptionid)
this function returns the subscription which has \f(CW$subscriptionid\fR as id.
return :
a hashref. This hash containts
subscription, subscriptionhistory, aqbudget.bookfundid, biblio.title
.SS "GetFullSubscription"
.IX Subsection "GetFullSubscription"
.Vb 2
\&   $array_ref = GetFullSubscription($subscriptionid)
\&   this function reads the serial table.
.Ve
.SS "PrepareSerialsData"
.IX Subsection "PrepareSerialsData"
.Vb 2
\&   $array_ref = PrepareSerialsData($serialinfomation)
\&   where serialinformation is a hashref array
.Ve
.SS "GetSubscriptionsFromBiblionumber"
.IX Subsection "GetSubscriptionsFromBiblionumber"
\&\f(CW$array_ref\fR = GetSubscriptionsFromBiblionumber($biblionumber)
this function get the subscription list. it reads the subscription table.
return :
reference to an array of subscriptions which have the biblionumber given on input arg.
each element of this array is a hashref containing
startdate, histstartdate,opacnote,missinglist,recievedlist,periodicity,status & enddate
.SS "GetFullSubscriptionsFromBiblionumber"
.IX Subsection "GetFullSubscriptionsFromBiblionumber"
.Vb 2
\&   $array_ref = GetFullSubscriptionsFromBiblionumber($biblionumber)
\&   this function reads the serial table.
.Ve
.SS "GetSubscriptions"
.IX Subsection "GetSubscriptions"
\&\f(CW@results\fR = GetSubscriptions($title,$ISSN,$ean,$biblionumber);
this function gets all subscriptions which have title like \f(CW$title\fR,ISSN like \f(CW$ISSN\fR,EAN like \f(CW$ean\fR and biblionumber like \f(CW$biblionumber\fR.
return:
a table of hashref. Each hash containt the subscription.
.SS "GetSerials"
.IX Subsection "GetSerials"
($totalissues,@serials) = GetSerials($subscriptionid);
this function gets every serial not arrived for a given subscription
as well as the number of issues registered in the database (all types)
this number is used to see if a subscription can be deleted (=it must have only 1 issue)
.PP
\&\s-1FIXME:\s0 We should return \e@serials.
.SS "GetSerials2"
.IX Subsection "GetSerials2"
\&\f(CW@serials\fR = GetSerials2($subscriptionid,$status);
this function returns every serial waited for a given subscription
as well as the number of issues registered in the database (all types)
this number is used to see if a subscription can be deleted (=it must have only 1 issue)
.SS "GetLatestSerials"
.IX Subsection "GetLatestSerials"
\&\e@serials = GetLatestSerials($subscriptionid,$limit)
get the \f(CW$limit\fR's latest serials arrived or missing for a given subscription
return :
a ref to an array which contains all of the latest serials stored into a hash.
.SS "GetDistributedTo"
.IX Subsection "GetDistributedTo"
\&\f(CW$distributedto\fR=GetDistributedTo($subscriptionid)
This function returns the field distributedto for the subscription matching subscriptionid
.SS "GetNextSeq"
.IX Subsection "GetNextSeq"
GetNextSeq($val)
\&\f(CW$val\fR is a hashref containing all the attributes of the table 'subscription'
This function get the next issue for the subscription given on input arg
return:
a list containing all the input params updated.
.SS "GetSeq"
.IX Subsection "GetSeq"
\&\f(CW$calculated\fR = GetSeq($val)
\&\f(CW$val\fR is a hashref containing all the attributes of the table 'subscription'
this function transforms {X},{Y},{Z} to 150,0,0 for example.
return:
the sequence in integer format
.SS "GetExpirationDate"
.IX Subsection "GetExpirationDate"
\&\f(CW$enddate\fR = GetExpirationDate($subscriptionid, [$startdate])
.PP
this function return the next expiration date for a subscription given on input args.
.PP
return
the enddate or undef
.SS "CountSubscriptionFromBiblionumber"
.IX Subsection "CountSubscriptionFromBiblionumber"
\&\f(CW$subscriptionsnumber\fR = CountSubscriptionFromBiblionumber($biblionumber)
this returns a count of the subscriptions for a given biblionumber
return :
the number of subscriptions
.SS "ModSubscriptionHistory"
.IX Subsection "ModSubscriptionHistory"
ModSubscriptionHistory($subscriptionid,$histstartdate,$enddate,$recievedlist,$missinglist,$opacnote,$librariannote);
.PP
this function modifies the history of a subscription. Put your new values on input arg.
returns the number of rows affected
.SS "ModSerialStatus"
.IX Subsection "ModSerialStatus"
ModSerialStatus($serialid,$serialseq, \f(CW$planneddate\fR,$publisheddate,$status,$notes)
.PP
This function modify the serial status. Serial status is a number.(eg 2 is \*(L"arrived\*(R")
Note : if we change from \*(L"waited\*(R" to something else,then we will have to create a new \*(L"waited\*(R" entry
.SS "GetNextExpected"
.IX Subsection "GetNextExpected"
\&\f(CW$nextexpected\fR = GetNextExpected($subscriptionid)
.PP
Get the planneddate for the current expected issue of the subscription.
.PP
returns a hashref:
.PP
\&\f(CW$nextexepected\fR = {
    serialid => int
    planneddate => C4::Dates object
    }
.SS "ModNextExpected"
.IX Subsection "ModNextExpected"
ModNextExpected($subscriptionid,$date)
.PP
Update the planneddate for the current expected issue of the subscription.
This will modify all future prediction results.
.PP
\&\f(CW$date\fR is a C4::Dates object.
.PP
returns 0
.SS "ModSubscription"
.IX Subsection "ModSubscription"
this function modifies a subscription. Put all new values on input args.
returns the number of rows affected
.SS "NewSubscription"
.IX Subsection "NewSubscription"
\&\f(CW$subscriptionid\fR = &NewSubscription($auser,branchcode,$aqbooksellerid,$cost,$aqbudgetid,$biblionumber,
    \f(CW$startdate\fR,$periodicity,$dow,$numberlength,$weeklength,$monthlength,
    \f(CW$add1\fR,$every1,$whenmorethan1,$setto1,$lastvalue1,$innerloop1,
    \f(CW$add2\fR,$every2,$whenmorethan2,$setto2,$lastvalue2,$innerloop2,
    \f(CW$add3\fR,$every3,$whenmorethan3,$setto3,$lastvalue3,$innerloop3,
    \f(CW$numberingmethod\fR, \f(CW$status\fR, \f(CW$notes\fR, \f(CW$serialsadditems\fR,
    \f(CW$staffdisplaycount\fR, \f(CW$opacdisplaycount\fR, \f(CW$graceperiod\fR, \f(CW$location\fR, \f(CW$enddate\fR);
.PP
Create a new subscription with value given on input args.
.PP
return :
the id of this new subscription
.SS "ReNewSubscription"
.IX Subsection "ReNewSubscription"
ReNewSubscription($subscriptionid,$user,$startdate,$numberlength,$weeklength,$monthlength,$note)
.PP
this function renew a subscription with values given on input args.
.SS "NewIssue"
.IX Subsection "NewIssue"
NewIssue($serialseq,$subscriptionid,$biblionumber,$status, \f(CW$planneddate\fR, \f(CW$publisheddate\fR,  \f(CW$notes\fR)
.PP
Create a new issue stored on the database.
Note : we have to update the recievedlist and missinglist on subscriptionhistory for this subscription.
returns the serial id
.SS "ItemizeSerials"
.IX Subsection "ItemizeSerials"
ItemizeSerials($serialid, \f(CW$info\fR);
\&\f(CW$info\fR is a hashref containing  barcode branch, itemcallnumber, status, location
\&\f(CW$serialid\fR the serialid
return :
1 if the itemize is a succes.
0 and \f(CW@error\fR otherwise. \f(CW@error\fR containts the list of errors found.
.SS "HasSubscriptionStrictlyExpired"
.IX Subsection "HasSubscriptionStrictlyExpired"
1 or 0 = HasSubscriptionStrictlyExpired($subscriptionid)
.PP
the subscription has stricly expired when today > the end subscription date
.PP
return :
1 if true, 0 if false, \-1 if the expiration date is not set.
.SS "HasSubscriptionExpired"
.IX Subsection "HasSubscriptionExpired"
\&\f(CW$has_expired\fR = HasSubscriptionExpired($subscriptionid)
.PP
the subscription has expired when the next issue to arrive is out of subscription limit.
.PP
return :
0 if the subscription has not expired
1 if the subscription has expired
2 if has subscription does not have a valid expiration date set
.SS "SetDistributedto"
.IX Subsection "SetDistributedto"
SetDistributedto($distributedto,$subscriptionid);
This function update the value of distributedto for a subscription given on input arg.
.SS "DelSubscription"
.IX Subsection "DelSubscription"
DelSubscription($subscriptionid)
this function deletes subscription which has \f(CW$subscriptionid\fR as id.
.SS "DelIssue"
.IX Subsection "DelIssue"
DelIssue($serialseq,$subscriptionid)
this function deletes an issue which has \f(CW$serialseq\fR and \f(CW$subscriptionid\fR given on input arg.
.PP
returns the number of rows affected
.SS "GetLateOrMissingIssues"
.IX Subsection "GetLateOrMissingIssues"
\&\f(CW@issuelist\fR = GetLateMissingIssues($supplierid,$serialid)
.PP
this function selects missing issues on database \- where serial.status = 4 or serial.status=3 or planneddate<now
.PP
return :
the issuelist as an array of hash refs. Each element of this array contains 
name,title,planneddate,serialseq,serial.subscriptionid from tables : subscription, serial & biblio
.SS "removeMissingIssue"
.IX Subsection "removeMissingIssue"
removeMissingIssue($subscriptionid)
.PP
this function removes an issue from being part of the missing string in 
subscriptionlist.missinglist column
.PP
called when a missing issue is found from the serials\-recieve.pl file
.SS "updateClaim"
.IX Subsection "updateClaim"
&updateClaim($serialid)
.PP
this function updates the time when a claim is issued for late/missing items
.PP
called from claims.pl file
.SS "getsupplierbyserialid"
.IX Subsection "getsupplierbyserialid"
\&\f(CW$result\fR = getsupplierbyserialid($serialid)
.PP
this function is used to find the supplier id given a serial id
.PP
return :
hashref containing serialid, subscriptionid, and aqbooksellerid
.SS "check_routing"
.IX Subsection "check_routing"
\&\f(CW$result\fR = &check_routing($subscriptionid)
.PP
this function checks to see if a serial has a routing list and returns the count of routingid
used to show either an 'add' or 'edit' link
.SS "addroutingmember"
.IX Subsection "addroutingmember"
addroutingmember($borrowernumber,$subscriptionid)
.PP
this function takes a borrowernumber and subscriptionid and adds the member to the
routing list for that serial subscription and gives them a rank on the list
of either 1 or highest current rank + 1
.SS "reorder_members"
.IX Subsection "reorder_members"
reorder_members($subscriptionid,$routingid,$rank)
.PP
this function is used to reorder the routing list
.PP
it takes the routingid of the member one wants to re-rank and the rank it is to move to
\&\- it gets all members on list puts their routingid's into an array
\&\- removes the one in the array that is \f(CW$routingid\fR
\&\- then reinjects \f(CW$routingid\fR at point indicated by \f(CW$rank\fR
\&\- then update the database with the routingids in the new order
.SS "delroutingmember"
.IX Subsection "delroutingmember"
delroutingmember($routingid,$subscriptionid)
.PP
this function either deletes one member from routing list if \f(CW$routingid\fR exists otherwise
deletes all members from the routing list
.SS "getroutinglist"
.IX Subsection "getroutinglist"
\&\f(CW@routinglist\fR = getroutinglist($subscriptionid)
.PP
this gets the info from the subscriptionroutinglist for \f(CW$subscriptionid\fR
.PP
return :
the routinglist as an array. Each element of the array contains a hash_ref containing
routingid \- a unique id, borrowernumber, ranking, and biblionumber of subscription
.SS "countissuesfrom"
.IX Subsection "countissuesfrom"
\&\f(CW$result\fR = countissuesfrom($subscriptionid,$startdate)
.PP
Returns a count of serial rows matching the given subsctiptionid
with published date greater than startdate
.SS "CountIssues"
.IX Subsection "CountIssues"
\&\f(CW$result\fR = CountIssues($subscriptionid)
.PP
Returns a count of serial rows matching the given subsctiptionid
.SS "HasItems"
.IX Subsection "HasItems"
\&\f(CW$result\fR = HasItems($subscriptionid)
.PP
returns a count of items from serial matching the subscriptionid
.SS "abouttoexpire"
.IX Subsection "abouttoexpire"
\&\f(CW$result\fR = abouttoexpire($subscriptionid)
.PP
this function alerts you to the penultimate issue for a serial subscription
.PP
returns 1 \- if this is the penultimate issue
returns 0 \- if not
.SS "GetNextDate"
.IX Subsection "GetNextDate"
\&\f(CW$resultdate\fR = GetNextDate($planneddate,$subscription)
.PP
this function it takes the planneddate and will return the next issue's date and will skip dates if there
exists an irregularity
\&\- eg if periodicity is monthly and \f(CW$planneddate\fR is 2007\-02\-10 but if March and April is to be 
skipped then the returned date will be 2007\-05\-10
.PP
return :
\&\f(CW$resultdate\fR \- then next date in the sequence
.PP
Return 0 if periodicity==0
.SS "is_barcode_in_use"
.IX Subsection "is_barcode_in_use"
Returns number of occurence of the barcode in the items table
Can be used as a boolean test of whether the barcode has
been deployed as yet
.SH "AUTHOR"
.IX Header "AUTHOR"
Koha Development Team <http://koha\-community.org/>
