.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "C4::Installer 3pm"
.TH C4::Installer 3pm "2012-07-16" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Installer
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\& use C4::Installer;
\& my $installer = C4::Installer\->new();
\& my $all_languages = getAllLanguages();
\& my $error = $installer\->load_db_schema();
\& my $list = $installer\->sql_file_list(\*(Aqen\*(Aq, \*(Aqmarc21\*(Aq, { optional => 1, mandatory => 1 });
\& my ($fwk_language, $error_list) = $installer\->load_sql_in_order($all_languages, @$list);
\& $installer\->set_version_syspref();
\& $installer\->set_marcflavour_syspref(\*(AqMARC21\*(Aq);
\& $installer\->set_indexing_engine(0);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $installer = C4::Installer\->new();
.Ve
.PP
Creates a new installer.
.SS "marcflavour_list"
.IX Subsection "marcflavour_list"
.Vb 1
\&  my ($marcflavours) = $installer\->marcflavour_list($lang);
.Ve
.PP
Return a arrayref of the \s-1MARC\s0 flavour sets available for the
specified language \f(CW$lang\fR.  Returns 'undef' if a directory
for the language does not exist.
.SS "marc_framework_sql_list"
.IX Subsection "marc_framework_sql_list"
.Vb 2
\&  my ($defaulted_to_en, $list) = 
\&     $installer\->marc_framework_sql_list($lang, $marcflavour);
.Ve
.PP
Returns in \f(CW$list\fR a structure listing the filename, description, section,
and mandatory/optional status of \s-1MARC\s0 framework scripts available for \f(CW$lang\fR
and \f(CW$marcflavour\fR.
.PP
If the \f(CW$defaulted_to_en\fR return value is true, no scripts are available
for language \f(CW$lang\fR and the 'en' ones are returned.
.SS "sample_data_sql_list"
.IX Subsection "sample_data_sql_list"
.Vb 1
\&  my ($defaulted_to_en, $list) = $installer\->sample_data_sql_list($lang);
.Ve
.PP
Returns in \f(CW$list\fR a structure listing the filename, description, section,
and mandatory/optional status of sample data scripts available for \f(CW$lang\fR.
If the \f(CW$defaulted_to_en\fR return value is true, no scripts are available
for language \f(CW$lang\fR and the 'en' ones are returned.
.SS "sql_file_list"
.IX Subsection "sql_file_list"
.Vb 1
\&  my $list = $installer\->sql_file_list($lang, $marcflavour, $subset_wanted);
.Ve
.PP
Returns an arrayref containing the filepaths of installer \s-1SQL\s0 scripts
available for laod.  The \f(CW$lang\fR and \f(CW$marcflavour\fR arguments
specify the desired language and \s-1MARC\s0 flavour. while \f(CW$subset_wanted\fR
is a hashref containing possible named parameters 'mandatory' and 'optional'.
.SS "load_db_schema"
.IX Subsection "load_db_schema"
.Vb 1
\&  my $error = $installer\->load_db_schema();
.Ve
.PP
Loads the \s-1SQL\s0 script that creates Koha's tables and indexes.  The
return value is a string containing error messages reported by the
load.
.SS "load_sql_in_order"
.IX Subsection "load_sql_in_order"
.Vb 1
\&  my ($fwk_language, $list) = $installer\->load_sql_in_order($all_languages, @sql_list);
.Ve
.PP
Given a list of \s-1SQL\s0 scripts supplied in \f(CW@sql_list\fR, loads each of them
into the database and sets the FrameworksLoaded system preference to names
of the scripts that were loaded.
.PP
The \s-1SQL\s0 files are loaded in alphabetical order by filename (not including
directory path).  This means that dependencies among the scripts are to
be resolved by carefully naming them, keeping in mind that the directory name
does *not* currently count.
.PP
\&\fB\s-1FIXME:\s0\fR this is a rather delicate way of dealing with dependencies between
the install scripts.
.PP
The return value \f(CW$list\fR is an arrayref containing a hashref for each
\&\*(L"level\*(R" or directory containing \s-1SQL\s0 scripts; the hashref in turns contains
a list of hashrefs containing a list of each script load and any error
messages associated with the loading of each script.
.PP
\&\fB\s-1FIXME:\s0\fR The \f(CW$fwk_language\fR code probably doesn't belong and needs to be
moved to a different method.
.SS "set_marcflavour_syspref"
.IX Subsection "set_marcflavour_syspref"
.Vb 1
\&  $installer\->set_marcflavour_syspref($marcflavour);
.Ve
.PP
Set the 'marcflavour' system preference.  The incoming
\&\f(CW$marcflavour\fR references to a subdirectory of
installer/data/$dbms/$lang/marcflavour, and is
normalized to \s-1MARC21\s0 or \s-1UNIMARC\s0.
.PP
\&\s-1FIXME:\s0 this method assumes that the \s-1MARC\s0 flavour will be either
\&\s-1MARC21\s0 or \s-1UNIMARC\s0.
.SS "set_indexing_engine"
.IX Subsection "set_indexing_engine"
.Vb 1
\&  $installer\->set_indexing_engine($nozebra);
.Ve
.PP
Sets system preferences related to the indexing
engine.  The \f(CW$nozebra\fR argument is a boolean;
if true, turn on NoZebra mode and turn off QueryFuzzy,
QueryWeightFields, and QueryStemming.  If false, turn
off NoZebra mode (i.e., use the Zebra search engine).
.SS "set_version_syspref"
.IX Subsection "set_version_syspref"
.Vb 1
\&  $installer\->set_version_syspref();
.Ve
.PP
Set or update the 'Version' system preference to the current
Koha software version.
.SS "load_sql"
.IX Subsection "load_sql"
.Vb 1
\&  my $error = $installer\->load_sql($filename);
.Ve
.PP
Runs a the specified \s-1SQL\s0 using the \s-1DB\s0's command-line
\&\s-1SQL\s0 tool, and returns any strings sent to \s-1STDERR\s0
by the command-line tool.
.PP
\&\fB\s-1FIXME:\s0\fR there has been a long-standing desire to
replace this with an \s-1SQL\s0 loader that goes
through \s-1DBI\s0; partly for portability issues
and partly to improve error handling.
.PP
\&\fB\s-1FIXME:\s0\fR even using the command-line loader, some more
basic error handling should be added \- deal
with missing files, e.g.
.SS "get_file_path_from_name"
.IX Subsection "get_file_path_from_name"
.Vb 1
\&  my $filename = $installer\->get_file_path_from_name(\*(Aqscript_name\*(Aq);
.Ve
.PP
searches through the set of known \s-1SQL\s0 scripts and finds the fully
qualified path name for the script that mathches the input.
.PP
returns undef if no match was found.
.SH "AUTHOR"
.IX Header "AUTHOR"
C4::Installer is a refactoring of logic originally from installer/installer.pl, which was
originally written by Henri-Damien Laurant.
.PP
Koha Development Team <http://koha\-community.org/>
.PP
Galen Charlton <galen.charlton@liblime.com>
