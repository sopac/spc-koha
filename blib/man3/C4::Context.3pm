.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "C4::Context 3pm"
.TH C4::Context 3pm "2012-07-03" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Context \- Maintain and manipulate the context of a Koha script
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use C4::Context;
\&
\&  use C4::Context("/path/to/koha\-conf.xml");
\&
\&  $config_value = C4::Context\->config("config_variable");
\&
\&  $koha_preference = C4::Context\->preference("preference");
\&
\&  $db_handle = C4::Context\->dbh;
\&
\&  $Zconn = C4::Context\->Zconn;
\&
\&  $stopwordhash = C4::Context\->stopwords;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
When a Koha script runs, it makes use of a certain number of things:
configuration settings in \fI/etc/koha/koha\-conf.xml\fR, a connection to the Koha
databases, and so forth. These things make up the \fIcontext\fR in which
the script runs.
.PP
This module takes care of setting up the context for a script:
figuring out which configuration file to load, and loading it, opening
a connection to the right database, and so forth.
.PP
Most scripts will only use one context. They can simply have
.PP
.Vb 1
\&  use C4::Context;
.Ve
.PP
at the top.
.PP
Other scripts may need to use several contexts. For instance, if a
library has two databases, one for a certain collection, and the other
for everything else, it might be necessary for a script to use two
different contexts to search both databases. Such scripts should use
the \f(CW&set_context\fR and \f(CW&restore_context\fR functions, below.
.PP
By default, C4::Context reads the configuration from
\&\fI/etc/koha/koha\-conf.xml\fR. This may be overridden by setting the \f(CW$KOHA_CONF\fR
environment variable to the pathname of a configuration file to use.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1KOHAVERSION\s0"
.IX Subsection "KOHAVERSION"
returns the kohaversion stored in kohaversion.pl file
.SS "read_config_file"
.IX Subsection "read_config_file"
Reads the specified Koha config file.
.PP
Returns an object containing the configuration variables. The object's
structure is a bit complex to the uninitiated ... take a look at the
koha\-conf.xml file as well as the XML::Simple documentation for details. Or,
here are a few examples that may give you what you need:
.PP
The simple elements nested within the <config> element:
.PP
.Vb 1
\&    my $pass = $koha\->{\*(Aqconfig\*(Aq}\->{\*(Aqpass\*(Aq};
.Ve
.PP
The <listen> elements:
.PP
.Vb 1
\&    my $listen = $koha\->{\*(Aqlisten\*(Aq}\->{\*(Aqbiblioserver\*(Aq}\->{\*(Aqcontent\*(Aq};
.Ve
.PP
The elements nested within the <server> element:
.PP
.Vb 1
\&    my $ccl2rpn = $koha\->{\*(Aqserver\*(Aq}\->{\*(Aqbiblioserver\*(Aq}\->{\*(Aqcql2rpn\*(Aq};
.Ve
.PP
Returns undef in case of error.
.SS "ismemcached"
.IX Subsection "ismemcached"
Returns the value of the \f(CW$ismemcached\fR variable (0/1)
.SS "memcached"
.IX Subsection "memcached"
If \f(CW$ismemcached\fR is true, returns the \f(CW$memcache\fR variable.
Returns undef otherwise
.SS "new"
.IX Subsection "new"
.Vb 2
\&  $context = new C4::Context;
\&  $context = new C4::Context("/path/to/koha\-conf.xml");
.Ve
.PP
Allocates a new context. Initializes the context from the specified
file, which defaults to either the file given by the \f(CW$KOHA_CONF\fR
environment variable, or \fI/etc/koha/koha\-conf.xml\fR.
.PP
It saves the koha\-conf.xml values in the declared memcached server(s)
if currently available and uses those values until them expire and
re-reads them.
.PP
\&\f(CW&new\fR does not set this context as the new default context; for
that, use \f(CW&set_context\fR.
.SS "set_context"
.IX Subsection "set_context"
.Vb 4
\&  $context = new C4::Context;
\&  $context\->set_context();
\&or
\&  set_context C4::Context $context;
\&
\&  ...
\&  restore_context C4::Context;
.Ve
.PP
In some cases, it might be necessary for a script to use multiple
contexts. \f(CW&set_context\fR saves the current context on a stack, then
sets the context to \f(CW$context\fR, which will be used in future
operations. To restore the previous context, use \f(CW&restore_context\fR.
.SS "restore_context"
.IX Subsection "restore_context"
.Vb 1
\&  &restore_context;
.Ve
.PP
Restores the context set by \f(CW&set_context\fR.
.SS "config"
.IX Subsection "config"
.Vb 1
\&  $value = C4::Context\->config("config_variable");
\&
\&  $value = C4::Context\->config_variable;
.Ve
.PP
Returns the value of a variable specified in the configuration file
from which the current context was created.
.PP
The second form is more compact, but of course may conflict with
method names. If there is a configuration variable called \*(L"new\*(R", then
\&\f(CW\*(C`C4::Config\->new\*(C'\fR will not return it.
.SS "preference"
.IX Subsection "preference"
.Vb 1
\&  $sys_preference = C4::Context\->preference(\*(Aqsome_variable\*(Aq);
.Ve
.PP
Looks up the value of the given system preference in the
systempreferences table of the Koha database, and returns it. If the
variable is not set or does not exist, undef is returned.
.PP
In case of an error, this may return 0.
.PP
Note: It is impossible to tell the difference between system
preferences which do not exist, and those whose values are set to \s-1NULL\s0
with this method.
.SS "clear_syspref_cache"
.IX Subsection "clear_syspref_cache"
.Vb 1
\&  C4::Context\->clear_syspref_cache();
.Ve
.PP
cleans the internal cache of sysprefs. Please call this method if
you update the systempreferences table. Otherwise, your new changes
will not be seen by this process.
.SS "set_preference"
.IX Subsection "set_preference"
.Vb 1
\&  C4::Context\->set_preference( $variable, $value );
.Ve
.PP
This updates a preference's value both in the systempreferences table and in
the sysprefs cache.
.SS "Zconn"
.IX Subsection "Zconn"
.Vb 1
\&  $Zconn = C4::Context\->Zconn
.Ve
.PP
Returns a connection to the Zebra database for the current
context. If no connection has yet been made, this method 
creates one and connects.
.PP
\&\f(CW$self\fR
.PP
\&\f(CW$server\fR one of the servers defined in the koha\-conf.xml file
.PP
\&\f(CW$async\fR whether this is a asynchronous connection
.PP
\&\f(CW$auth\fR whether this connection has rw access (1) or just r access (0 or \s-1NULL\s0)
.SS "_new_Zconn"
.IX Subsection "_new_Zconn"
\&\f(CW$context\fR\->{\*(L"Zconn\*(R"} = &_new_Zconn($server,$async);
.PP
Internal function. Creates a new database connection from the data given in the current context and returns it.
.PP
\&\f(CW$server\fR one of the servers defined in the koha\-conf.xml file
.PP
\&\f(CW$async\fR whether this is a asynchronous connection
.PP
\&\f(CW$auth\fR whether this connection has rw access (1) or just r access (0 or \s-1NULL\s0)
.SS "dbh"
.IX Subsection "dbh"
.Vb 1
\&  $dbh = C4::Context\->dbh;
.Ve
.PP
Returns a database handle connected to the Koha database for the
current context. If no connection has yet been made, this method
creates one, and connects to the database.
.PP
This database handle is cached for future use: if you call
\&\f(CW\*(C`C4::Context\->dbh\*(C'\fR twice, you will get the same handle both
times. If you need a second database handle, use \f(CW&new_dbh\fR and
possibly \f(CW&set_dbh\fR.
.SS "new_dbh"
.IX Subsection "new_dbh"
.Vb 1
\&  $dbh = C4::Context\->new_dbh;
.Ve
.PP
Creates a new connection to the Koha database for the current context,
and returns the database handle (a \f(CW\*(C`DBI::db\*(C'\fR object).
.PP
The handle is not saved anywhere: this method is strictly a
convenience function; the point is that it knows which database to
connect to so that the caller doesn't have to know.
.SS "set_dbh"
.IX Subsection "set_dbh"
.Vb 4
\&  $my_dbh = C4::Connect\->new_dbh;
\&  C4::Connect\->set_dbh($my_dbh);
\&  ...
\&  C4::Connect\->restore_dbh;
.Ve
.PP
\&\f(CW&set_dbh\fR and \f(CW&restore_dbh\fR work in a manner analogous to
\&\f(CW&set_context\fR and \f(CW&restore_context\fR.
.PP
\&\f(CW&set_dbh\fR saves the current database handle on a stack, then sets
the current database handle to \f(CW$my_dbh\fR.
.PP
\&\f(CW$my_dbh\fR is assumed to be a good database handle.
.SS "restore_dbh"
.IX Subsection "restore_dbh"
.Vb 1
\&  C4::Context\->restore_dbh;
.Ve
.PP
Restores the database handle saved by an earlier call to
\&\f(CW\*(C`C4::Context\->set_dbh\*(C'\fR.
.SS "marcfromkohafield"
.IX Subsection "marcfromkohafield"
.Vb 1
\&  $dbh = C4::Context\->marcfromkohafield;
.Ve
.PP
Returns a hash with marcfromkohafield.
.PP
This hash is cached for future use: if you call
\&\f(CW\*(C`C4::Context\->marcfromkohafield\*(C'\fR twice, you will get the same hash without real \s-1DB\s0 access
.SS "stopwords"
.IX Subsection "stopwords"
.Vb 1
\&  $dbh = C4::Context\->stopwords;
.Ve
.PP
Returns a hash with stopwords.
.PP
This hash is cached for future use: if you call
\&\f(CW\*(C`C4::Context\->stopwords\*(C'\fR twice, you will get the same hash without real \s-1DB\s0 access
.SS "userenv"
.IX Subsection "userenv"
.Vb 1
\&  C4::Context\->userenv;
.Ve
.PP
Retrieves a hash for user environment variables.
.PP
This hash shall be cached for future use: if you call
\&\f(CW\*(C`C4::Context\->userenv\*(C'\fR twice, you will get the same hash without real \s-1DB\s0 access
.SS "set_userenv"
.IX Subsection "set_userenv"
.Vb 2
\&  C4::Context\->set_userenv($usernum, $userid, $usercnum, $userfirstname, 
\&                  $usersurname, $userbranch, $userflags, $emailaddress);
.Ve
.PP
Establish a hash of user environment variables.
.PP
set_userenv is called in Auth.pm
.SS "_new_userenv"
.IX Subsection "_new_userenv"
.Vb 1
\&  C4::Context\->_new_userenv($session);  # FIXME: This calling style is wrong for what looks like an _internal function
.Ve
.PP
Builds a hash for user environment variables.
.PP
This hash shall be cached for future use: if you call
\&\f(CW\*(C`C4::Context\->userenv\*(C'\fR twice, you will get the same hash without real \s-1DB\s0 access
.PP
_new_userenv is called in Auth.pm
.SS "_unset_userenv"
.IX Subsection "_unset_userenv"
.Vb 1
\&  C4::Context\->_unset_userenv;
.Ve
.PP
Destroys the hash for activeuser user environment variables.
.SS "get_versions"
.IX Subsection "get_versions"
.Vb 1
\&  C4::Context\->get_versions
.Ve
.PP
Gets various version info, for core Koha packages, Currently called from carp \fIhandle_errors()\fR sub, to send to browser if 'DebugLevel' syspref is set to '2'.
.SS "tz"
.IX Subsection "tz"
.Vb 1
\&  C4::Context\->tz
\&
\&  Returns a DateTime::TimeZone object for the system timezone
.Ve
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.ie n .SS """KOHA_CONF"""
.el .SS "\f(CWKOHA_CONF\fP"
.IX Subsection "KOHA_CONF"
Specifies the configuration file to read.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
XML::Simple
.SH "AUTHORS"
.IX Header "AUTHORS"
Andrew Arensburger <arensb at ooblick dot com>
.PP
Joshua Ferraro <jmf at liblime dot com>
